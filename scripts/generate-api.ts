import { writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { apiManifest } from '../server/routes.ts';

function header() {
  return `// AUTO-GENERATED by scripts/generate-api.ts\n// Do not edit this file directly.\n\n`;
}

function buildApiFetch() {
  return `type FetchOptions = Omit<RequestInit, "body" | "method"> & {\n  params?: Record<string, string | number>;\n  body?: any;\n};\n\nfunction buildUrl(pattern: string, params?: Record<string, string | number>) {\n  let url = pattern;\n  if (params) {\n    for (const [key, value] of Object.entries(params)) {\n      url = url.replace(\`:\${key}\`, String(value));\n    }\n  }\n  return url;\n}\n\nasync function apiFetch(path: string, method: string, options: FetchOptions = {}) {\n  const { params, body, ...rest } = options;\n  const url = buildUrl(path, params);\n  const response = await fetch(url, {\n    method,\n    ...rest,\n    headers: {\n      'Content-Type': 'application/json',\n      ...(rest.headers ?? {}),\n    },\n    body: body != null ? JSON.stringify(body) : undefined,\n  });\n  return response;\n}\n\nexport { apiFetch };\n`; 
}

function extractTypes(typeStr?: string): string[] {
  if (!typeStr) return [];
  const cleaned = typeStr.replace(/\[\]/g, '');
  const matches = cleaned.match(/\b[A-Z][A-Za-z0-9_]*\b/g) ?? [];
  return matches.filter((t) => t !== 'Number' && t !== 'String' && t !== 'Boolean' && t !== 'void');
}

function imports() {
  const types = new Set<string>();
  for (const e of apiManifest) {
    extractTypes(e.requestType).forEach((t) => types.add(t));
    extractTypes(e.responseType).forEach((t) => types.add(t));
  }
  const typeList = Array.from(types).sort();
  return typeList.length ? `import type { ${typeList.join(', ')} } from './types';\n` : '';
}

function buildHelpers() {
  const lines: string[] = [];
  lines.push('export const $api = {');
  for (const e of apiManifest) {
    const name = e.name;
    const method = e.method;
    const path = e.path;
    const resT = e.responseType;
    const reqT = e.requestType;
    const paramsT = e.paramsType;
    // Signature
    let sig = '';
    let bodyArg = '';
    let paramsArg = '';
    if (reqT && paramsT) {
      sig = `(params: ${paramsT}, body: ${reqT}, options?: FetchOptions): Promise<${resT}>`;
      paramsArg = 'params';
      bodyArg = 'body';
    } else if (reqT) {
      sig = `(body: ${reqT}, options?: FetchOptions): Promise<${resT}>`;
      bodyArg = 'body';
    } else if (paramsT) {
      sig = `(params: ${paramsT}, options?: FetchOptions): Promise<${resT}>`;
      paramsArg = 'params';
    } else {
      sig = `(options?: FetchOptions): Promise<${resT}>`;
    }

    lines.push(`  ${name}: async ${sig} => {`);
    const optsParts: string[] = [];
    if (paramsArg) optsParts.push(`params: ${paramsArg}`);
    if (bodyArg) optsParts.push(`body: ${bodyArg}`);
    const baseSpread = `...(options ?? {})`;
    const objOptions = optsParts.length
      ? `{ ${baseSpread}, ${optsParts.join(', ')} }`
      : `{ ${baseSpread} }`;
    lines.push(`    const res = await apiFetch('${path}', '${method}', ${objOptions});`);
    lines.push(`    if (!res.ok) {`);
    lines.push(`      const text = await res.text().catch(() => '');`);
    lines.push(`      throw new Error(\`Request failed: \${res.status} \${text}\`);`);
    lines.push(`    }`);
    lines.push(`    return res.json() as Promise<${resT}>;`);
    lines.push('  },');
  }
  lines.push('};\n');
  return lines.join('\n');
}

function generate() {
  const out = [header(), imports(), buildApiFetch(), buildHelpers()].join('\n');
  const file = resolve(process.cwd(), 'src', 'api.ts');
  writeFileSync(file, out, 'utf8');
  console.log(`[generate-api] Wrote ${file}`);
}

generate();